1- Um dos primeiros métodos de criptografia foi a cifra de césar usada por Júlio César onde consiste pegar uma mensagem e deslocá-la alguns caracteres para a direita.

2- A função de hash utilizada em criptografia mistura informações de um documento e as envia para alguém, os caracteres gerados pela função de hash não podem ser transformados de novo para a mensagem original.
Algumas características dos hashes:
    *Sem colisões: um hash gerado por uma palavra não pode ser gerado futuramente de novo para qualquer outra mensagem
    *Tamanho fixo: todas tem um tamanho fixo independentemente do tamanho da mensagem que foi criptografada. Isso é para evitar que se tenha alguma ideia de qual seja a mensagem original
    *Demore um pouco para ser realizado: dependendo da aplicação que esteja sendo desenvolvida, é necessário que haja alguma complexidade nesse hash pois atualmente existem equipamentos que conseguem descobrir qual palavra foi utilizada.

3- Por medidas de segurança, quando um usuário criar uma senha é melhor armazenar o hash do usuário ao invés da senha, isso de acordo com a ALURA. No entanto como os apps de banco sabem se eu já utilizei a senha quando eu tento trocar de senha. A explicação para isso é uma comparação entre a hash gerada no momento da autenticação e a hash guardada no banco de dados. No entanto ainda acho que não explica o caso dos bancos

4- A biblioteca crypto já é padrão do javascript, não sendo necessário baixar nada, somente importar

5- https://cursos.alura.com.br/course/nodejs-criptografia-tokens-jwt/task/107362

6- O método sal no hash adiciona mais um componente no hash que gera um hash totalmente diferente do hash normalmente utilizado, dificultando assim a utilização de rainbow table. 

7- Para poder enviar e receber informações entre usuários um dos métodos utilizados é a encriptação simétrica onde a mensagem enviada é encriptada porém quem envia e quem recebe possui uma chave compartilhada utilizada para ler a informação, sem ela a mensagem é somente um monte de letras e números.

8- No arquivo encriptacaoSimetrica.js eu tenho que gerar o tamanho correto de bytes para cada tipo de encriptação utilizada. Algoritmo de encriptação aes-256-ocb e aes-256-ccm não funcionaram com a quantidade de bytes que eu utilizei acima, somente o aes-256-gcm que funcionou com a quantidade de bytes utilizadas (32 bytes para a chave e 16 para a VI). No entanto usar aes-256-gcm não serviu para decifrar a palavra, somente o algoritmo aes256 funcionou para os dois, tanto para cifrar quanto para decifrar a mensagem.

9- Não entendi ao certo da necessidade de colocar .final na variável mensagemCifrada e mensagemDecifrada. Se eu colocar sem o .final ocorre a encriptação da mensagem, porém ela fica bem mais reduzida e a mensagem decifrada não é possível decifrar.